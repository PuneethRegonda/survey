# main_auto_fill.py
# Qualtrics survey auto-filler (CSV + mapping.json)
# Updates:
#  - Text inputs typed with human-like behavior, then VERIFIED; robust fallback (.fill + JS set + events)
#  - Radio/checkbox robust selection (id/label/span/choice/JS click) with verification
#  - After clicking Next, we WAIT for a real page-change via URL OR DOM signature (no “old id” hangs)
#  - Debug dumps for MC groups; pause at QID74 for manual approval

import asyncio, json, argparse, re, sys, platform, random
from pathlib import Path
from typing import Dict, Any, Optional, Tuple

import pandas as pd
from playwright.async_api import async_playwright, TimeoutError as PwTimeout

# ---------------- settings & utils ----------------
TEXT_INPUT_TYPES = {
    "text","email","tel","url","password","search","number","date","time","datetime-local",""
}
DEBUG = False
def dbg(*a):
    if DEBUG:
        print("[DEBUG]", *a)

def norm(s: str) -> str:
    return re.sub(r"\s+", " ", str(s or "")).strip()

def csv_get(row: Dict[str, Any], header: str) -> str:
    try:
        return str(row.get(header, "") or "")
    except Exception:
        return ""

async def exists(page, selector: str) -> bool:
    try:
        return await page.locator(selector).count() > 0
    except Exception:
        return False

def to_css_from_id_or_css(entry: Dict[str, Any]) -> str:
    if "id" in entry and entry["id"]:
        return f'#{entry["id"]}'
    if "css" in entry and entry["css"]:
        css = entry["css"]
        return css if css.startswith(("css=","#",".")) else f"css={css}"
    raise ValueError("Entry needs 'id' or 'css'")

# ---------------- Human typing + verification ----------------
async def _clear_input(page, loc):
    try:
        await loc.click()
    except Exception:
        pass
    try:
        if platform.system() == "Darwin":
            await page.keyboard.press("Meta+A")
        else:
            await page.keyboard.press("Control+A")
        await page.keyboard.press("Backspace")
    except Exception:
        try:
            await loc.fill("")
        except Exception:
            pass

async def _blur_field(page, loc):
    try:
        await loc.blur()
    except Exception:
        pass
    try:
        await page.mouse.click(10, 10)
    except Exception:
        pass

async def _js_set_value_and_events(page, sel: str, value: str):
    try:
        await page.evaluate(
            """(selector, v) => {
                const el = document.querySelector(selector);
                if (!el) return false;
                const setter = Object.getOwnPropertyDescriptor(el.__proto__, 'value')?.set;
                if (setter) { setter.call(el, v); } else { el.value = v; }
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
                el.dispatchEvent(new Event('blur', { bubbles: true }));
                return true;
            }""",
            sel, value
        )
        return True
    except Exception:
        return False

async def type_like_human_with_verify(page, sel: str, value: str,
                                      per_char_delay_ms: int = 80,
                                      retries: int = 2) -> bool:
    """Type char-by-char, verify input_value==value; retry with .fill() then JS set."""
    loc = page.locator(sel)
    await loc.scroll_into_view_if_needed()
    await loc.wait_for(state="visible", timeout=6000)

    for attempt in range(retries + 1):
        try:
            await loc.click()
        except Exception:
            pass

        # robust clear
        await _clear_input(page, loc)
        await page.wait_for_timeout(60)

        # type char-by-char
        try:
            await loc.type(value, delay=per_char_delay_ms)
        except Exception:
            await page.keyboard.type(value, delay=per_char_delay_ms)

        await page.wait_for_timeout(120)
        try:
            typed = await loc.input_value()
        except Exception:
            typed = ""

        if typed == value:
            await _blur_field(page, loc)
            await page.wait_for_timeout(180)
            return True

        dbg(f"Typed mismatch on {sel}. got='{typed}' expected='{value}' (attempt {attempt+1})")

        # fallback 1: fill()
        try:
            await loc.fill(value)
            await page.wait_for_timeout(80)
            typed = await loc.input_value()
            if typed == value:
                await _blur_field(page, loc)
                await page.wait_for_timeout(150)
                return True
        except Exception as e:
            dbg(f".fill() failed on {sel}: {e}")

        # fallback 2: JS setter + events
        ok = await _js_set_value_and_events(page, sel, value)
        await page.wait_for_timeout(100)
        try:
            typed = await loc.input_value()
        except Exception:
            typed = ""
        if ok and typed == value:
            await _blur_field(page, loc)
            await page.wait_for_timeout(150)
            return True

    return False

# ---------------- combobox ----------------
async def choose_combobox_by_text(page, combo_id: str, text: str):
    if not text:
        return
    candidates = [
        f'#{combo_id}[role="combobox"]',
        f'#{combo_id}.select-menu.menu-button',
        f'#{combo_id}',
    ]
    handle = None
    for sel in candidates:
        if await exists(page, sel):
            handle = page.locator(sel).first
            break
    if not handle:
        print(f"[warn] combobox #{combo_id} not found")
        return
    await handle.click()
    try:
        await page.get_by_role("option", name=text, exact=True).click(timeout=3000)
        return
    except Exception:
        pass
    try:
        await page.locator(f'xpath=//li[normalize-space()="{text}"]').first.click(timeout=3000)
        return
    except Exception:
        pass
    try:
        await page.get_by_text(text, exact=True).first.click(timeout=3000)
    except Exception:
        print(f"[warn] combobox option not found by visible text: {text}")

# ---------------- debug helpers for MC groups ----------------
async def debug_dump_group(page, group: str):
    js = r"""
    (group) => {
      const inputs = Array.from(document.querySelectorAll(`input[name="${group}"]`));
      return inputs.map(el => {
        const id = el.id || null;
        const value = el.getAttribute('value') || null;
        const aria = el.getAttribute('aria-labelledby') || null;
        let labelText = null;
        if (aria) {
          const lab = document.getElementById(aria);
          if (lab) labelText = lab.innerText.trim();
        }
        const choice = el.closest('.choice');
        const selected = (choice && choice.classList && choice.classList.contains('selected')) || el.checked || false;
        return { id, value, aria, labelText, selected };
      });
    }
    """
    try:
        rows = await page.evaluate(js, group)
        print(f"[debug] Group {group} options:")
        for r in rows:
            print(f"  id={r['id']!r} value={r['value']!r} aria={r['aria']!r} "
                  f"label={r['labelText']!r} selected={r['selected']}")
    except Exception as e:
        print(f"[debug] debug_dump_group({group}) failed: {e}")

# ---------------- radio/checkbox robust clicks ----------------
async def robust_click_mc(page, group: str, idx: str) -> bool:
    sel_input_id = f'#mc-choice-input-{group}-{idx}'
    sel_label_for = f'label[for="mc-choice-input-{group}-{idx}"]'
    sel_display   = f'#choice-display-{group}-{idx}'
    sel_choice    = f'xpath=//*[@id="mc-choice-input-{group}-{idx}"]/ancestor::*[contains(@class,"choice")][1]'
    sel_radio_btn = f'{sel_label_for} .radio-button'

    async def is_selected() -> bool:
        try:
            return await page.evaluate(
                """(sel) => {
                    const el = document.querySelector(sel);
                    if (!el) return false;
                    const choice = el.closest('.choice');
                    return (el.checked === true) || (choice && choice.classList && choice.classList.contains('selected'));
                }""",
                sel_input_id
            )
        except Exception:
            return False

    async def try_click(sel: str, how: str) -> bool:
        try:
            loc = page.locator(sel).first
            if await loc.count() == 0:
                return False
            await loc.scroll_into_view_if_needed()
            await loc.click(timeout=2000)
            await page.wait_for_timeout(80)
            if await is_selected():
                dbg(f"Selected via {how}: {sel}")
                return True
        except Exception as e:
            dbg(f"{how} click failed: {sel} ({e})")
        return False

    for _ in range(2):
        if await try_click(sel_input_id, "input id"):         return True
        if await try_click(sel_label_for, "label[for=...]"):  return True
        if await try_click(sel_display, "display span"):      return True
        if await try_click(sel_choice, "ancestor .choice"):   return True
        if await try_click(sel_radio_btn, ".radio-button"):   return True
        try:
            ok = await page.evaluate(
                """(sel) => {
                    const el = document.querySelector(sel);
                    if (!el) return false;
                    el.click();
                    el.dispatchEvent(new Event('input', {bubbles:true}));
                    el.dispatchEvent(new Event('change', {bubbles:true}));
                    const ch = el.closest('.choice');
                    if (ch && ch.classList) ch.classList.add('selected');
                    return true;
                }""",
                sel_input_id
            )
            await page.wait_for_timeout(100)
            if ok and await is_selected():
                dbg(f"Selected via JS click: {sel_input_id}")
                return True
        except Exception as e:
            dbg(f"JS click failed: {e}")
    return False

async def fill_radio_value_map(page, group: str, value_map: Dict[str,str], csv_value: str, other_text_css: str = None):
    if not csv_value:
        return
    want = value_map.get(csv_value)
    if want is None:
        for k, v in value_map.items():
            if norm(k).lower() == norm(csv_value).lower():
                want = v; break
    if want is None and any(norm(csv_value).lower().startswith(t) for t in ["other", "other (please specify)"]):
        for k, v in value_map.items():
            if k.lower().startswith("other"):
                want = v; break
    if not want:
        dbg(f"radio {group}: could not resolve value for CSV '{csv_value}'")
        return

    sel = f'input[type="radio"][name="{group}"][value="{want}"]'
    try:
        loc = page.locator(sel)
        if await loc.count() > 0:
            await loc.scroll_into_view_if_needed()
            await page.check(sel, force=True, timeout=2000)
            await page.wait_for_timeout(80)
            ok = await page.evaluate("""(sel)=>{
                const el = document.querySelector(sel);
                if (!el) return false;
                const ch = el.closest('.choice');
                return (el.checked===true) || (ch && ch.classList && ch.classList.contains('selected'));
            }""", sel)
            if ok:
                dbg(f"Checked via name+value: {sel}")
                if other_text_css and any(k.lower().startswith("other") and value_map.get(k) == want for k in value_map):
                    free = re.sub(r'^\s*other.*?:\s*', '', csv_value, flags=re.I).strip()
                    target = other_text_css if other_text_css.startswith(("css=","#",".")) else f"css={other_text_css}"
                    await fill_text_field(page, {"css": target[4:] if target.startswith("css=") else target}, free, per_char_delay_ms=80)
                return
    except Exception as e:
        dbg(f"name+value check failed: {e}")

    ok = await robust_click_mc(page, group, want)
    if ok and other_text_css and any(k.lower().startswith("other") and value_map.get(k) == want for k in value_map):
        free = re.sub(r'^\s*other.*?:\s*', '', csv_value, flags=re.I).strip()
        target = other_text_css if other_text_css.startswith(("css=","#",".")) else f"css={other_text_css}"
        await fill_text_field(page, {"css": target[4:] if target.startswith("css=") else target}, free, per_char_delay_ms=80)

async def fill_checkbox_multi(page, group: str, value_map: Optional[Dict[str,str]], csv_cell: str, delimiter: str = ";"):
    if not csv_cell:
        return
    wanted = [norm(p) for p in str(csv_cell).split(delimiter) if norm(p)]
    if not wanted:
        return

    used_any = False
    if value_map:
        for label in list(wanted):
            want = value_map.get(label)
            if want is None:
                for k, v in value_map.items():
                    if norm(k).lower() == label.lower():
                        want = v; break
            if want:
                sel = f'input[type="checkbox"][name="{group}"][value="{want}"]'
                try:
                    await page.check(sel, force=True, timeout=3000)
                    used_any = True
                except Exception as e:
                    dbg(f"checkbox check failed: {sel} ({e})")
        if used_any:
            return

    js = r"""
    (group) => {
      const out = [];
      const inputs = Array.from(document.querySelectorAll(`input[type="checkbox"][name="${group}"]`));
      for (const el of inputs) {
        const id = el.id || null;
        const v = el.getAttribute('value') || null;
        const aria = el.getAttribute('aria-labelledby') || null;
        let labelText = null;
        if (aria) {
          const lab = document.getElementById(aria);
          if (lab) labelText = lab.innerText.trim();
        }
        out.push({id, value: v, aria, labelText});
      }
      return out;
    }
    """
    try:
        options = await page.evaluate(js, group)
        for want_label in wanted:
            for opt in options:
                lab = norm(opt.get("labelText") or "")
                if lab and lab.lower() == want_label.lower():
                    if opt.get("id"):
                        try:
                            await page.check(f'#{opt["id"]}', force=True, timeout=2000)
                            break
                        except Exception:
                            pass
                    if opt.get("aria"):
                        try:
                            await page.click(f'#{opt["aria"]}', timeout=2000)
                            break
                        except Exception:
                            pass
    except Exception as e:
        dbg(f"checkbox label fallback failed: {e}")

# ---------------- nav & page-change detection ----------------
async def click_next_heuristic(page):
    try:
        btn = page.get_by_role("button", name=re.compile(r"^(Next|Continue|Proceed)$", re.I)).first
        if await btn.count() > 0:
            await btn.click()
            return True
    except Exception:
        pass
    selectors = [
        'button#next', '#next', 'button[data-role="next"]', '[aria-label="Next"]',
        'button:has-text("Next")', 'button:has-text("Continue")',
        'input[type="submit"][value*="Next"]', 'input[type="button"][value*="Next"]'
    ]
    for sel in selectors:
        try:
            if await page.locator(sel).count() > 0:
                await page.locator(sel).first.click()
                return True
        except Exception:
            continue
    return False

async def collect_page_signature(page) -> Dict[str, Any]:
    """Capture URL and a set of visible QID-related element IDs to detect page change."""
    return await page.evaluate(
        """() => {
            const ids = [];
            const pick = (nodeList) => nodeList.forEach(n => { if (n.id) ids.push('#'+n.id); });
            pick(document.querySelectorAll('[id^="question-display-QID"]'));
            pick(document.querySelectorAll('[id^="mc-choice-input-QID"]'));
            pick(document.querySelectorAll('[id^="form-text-input-QID"]'));
            pick(document.querySelectorAll('input[name^="QID"]'));
            return { url: location.href, ids: ids.slice(0, 60) };
        }"""
    )

async def wait_for_page_change(page, prev_sig: Dict[str, Any], timeout_ms: int = 15000) -> bool:
    """Wait for URL change OR >=60% of previous sentinel IDs to disappear."""
    try:
        await page.wait_for_function(
            """([prevUrl, prevIds]) => {
                const urlChanged = location.href !== prevUrl;
                const missing = prevIds.filter(sel => !document.querySelector(sel)).length;
                const ratio = prevIds.length ? (missing / prevIds.length) : 1;
                return urlChanged || ratio >= 0.60;
            }""",
            arg=[prev_sig.get("url",""), prev_sig.get("ids",[])],
            timeout=timeout_ms
        )
        return True
    except Exception:
        return False

# ---------------- text field wrapper ----------------
async def fill_text_field(page, entry: Dict[str, Any], value: str, per_char_delay_ms: int = 80):
    sel = to_css_from_id_or_css(entry)
    try:
        loc = page.locator(sel)
        await loc.wait_for(state="attached", timeout=6000)
        tag = await loc.evaluate("el => el.tagName.toLowerCase()")
        inp_type = await loc.evaluate("el => el.type ? el.type.toLowerCase() : ''")
        if tag == "select":
            try:
                await page.select_option(sel, value=value)
            except Exception:
                cleaned = sel[4:] if sel.startswith("css=") else sel
                v = await page.evaluate(
                    """(selector, desired) => {
                        const el = document.querySelector(selector);
                        if (!el) return null;
                        const want = String(desired).trim().toLowerCase();
                        for (const opt of el.options) {
                            const lbl = (opt.label || opt.text || '').trim().toLowerCase();
                            if (lbl === want) return opt.value;
                        }
                        return null;
                    }""", cleaned, value
                )
                if v:
                    await page.select_option(sel, value=v)
        elif tag in ("input","textarea") and (inp_type in TEXT_INPUT_TYPES):
            ok = await type_like_human_with_verify(page, sel, value, per_char_delay_ms=per_char_delay_ms)
            if not ok:
                print(f"[warn] Unable to set value for {sel} after retries.")
        else:
            await _js_set_value_and_events(page, sel, value)
            await _blur_field(page, loc)
    except Exception as e:
        print(f"[warn] fill_text_field failed for {sel}: {e}")

# ---------------- page filling ----------------
async def fill_present_fields_on_page(page, mapping: Dict[str, Any], row: Dict[str, Any], per_char_delay_ms: int):
    # TEXT
    for entry in mapping.get("text", []):
        try:
            sel = to_css_from_id_or_css(entry)
            if await exists(page, sel):
                await fill_text_field(page, entry, csv_get(row, entry["csv"]), per_char_delay_ms)
                await page.wait_for_timeout(120)
        except Exception as e:
            print(f"[warn] text entry failed: {e}")

    # RADIO
    for r in mapping.get("radio", []):
        group = r.get("group")
        if not group:
            continue
        if await exists(page, f'input[type="radio"][name="{group}"]'):
            if DEBUG:
                await debug_dump_group(page, group)

            if "default_if_nonempty" in r:
                val = csv_get(row, r["csv"])
                if val.strip():
                    idx = None
                    m = re.search(rf'mc-choice-input-{re.escape(group)}-(\d+)$', r["default_if_nonempty"])
                    if m:
                        idx = m.group(1)
                    ok = False
                    if idx:
                        ok = await robust_click_mc(page, group, idx)
                    if not ok:
                        try:
                            await page.check(r["default_if_nonempty"], force=True, timeout=2000)
                            ok = True
                            dbg(f"Checked using original selector: {r['default_if_nonempty']}")
                        except Exception:
                            pass
                    if not ok and "value_map" in r:
                        await fill_radio_value_map(page, group, r["value_map"], val, r.get("other_text_css"))
                    if DEBUG:
                        await debug_dump_group(page, group)
                    continue

            if "value_map" in r:
                await fill_radio_value_map(page, group, r["value_map"], csv_get(row, r["csv"]), r.get("other_text_css"))

    # CHECKBOX
    for c in mapping.get("checkbox", []):
        group = c.get("group")
        if not group:
            continue
        if await exists(page, f'input[type="checkbox"][name="{group}"]'):
            await fill_checkbox_multi(page, group, c.get("value_map"), csv_get(row, c["csv"]), c.get("multi_delimiter", ";"))

    # COMBOBOX
    for cb in mapping.get("combobox", []):
        cid = cb.get("id")
        if not cid:
            continue
        on_page = await exists(page, f'#{cid}') or await exists(page, f'#{cid}[role="combobox"]') or await exists(page, f'#{cid}.select-menu.menu-button')
        if on_page:
            await choose_combobox_by_text(page, cid, csv_get(row, cb["csv"]))

# ---------------- runner ----------------
async def run_row(playwright, start_url: str, mapping: Dict[str, Any], row: Dict[str, Any],
                  headless: bool, auto_next_after_qid74: bool, per_char_delay_ms: int):

    browser = await playwright.chromium.launch(headless=headless)
    ctx = await browser.new_context()
    page = await ctx.new_page()
    page.set_default_timeout(18000)

    await page.goto(start_url)
    await page.wait_for_load_state("domcontentloaded")

    qid74_css = 'input[aria-labelledby="question-display-QID74"]'

    for step in range(1, 90):
        await fill_present_fields_on_page(page, mapping, row, per_char_delay_ms)

        # Pause at QID74 for manual review
        if await exists(page, qid74_css):
            qid74_header = None
            for t in mapping.get("text", []):
                if ("id" in t and t["id"] == "question-display-QID74") or ("css" in t and "QID74" in str(t["css"])):
                    qid74_header = t["csv"]; break
            if not qid74_header:
                qid74_header = "Please confirm the email address where you would like to receive communications from Caltrain"
            email_val = row.get(qid74_header, "")
            if email_val:
                ok = await type_like_human_with_verify(page, qid74_css, str(email_val), per_char_delay_ms=per_char_delay_ms)
                if ok:
                    print(f"[info] QID74 typed with: {email_val}")
                else:
                    print(f"[warn] QID74 could not be set.")
            else:
                print("[info] QID74 CSV cell empty; leaving as-is.")
            print("\n=== PAUSED at QID74 for manual approval ===")
            print("Review the 'confirm email' field in the browser.")
            if auto_next_after_qid74:
                input("Press ENTER to click Next automatically (or Ctrl+C to abort)... ")
                sig = await collect_page_signature(page)
                clicked = await click_next_heuristic(page)
                changed = await wait_for_page_change(page, sig, timeout_ms=18000)
                print(f"[info] Next clicked? {clicked}. Page changed? {changed}. Ending run.")
            else:
                input("Press ENTER to end the run (you can click Next manually in the browser before pressing ENTER)... ")
            break

        # Try Next; if it doesn't navigate (validation), we stay and loop once more
        sig = await collect_page_signature(page)
        clicked = await click_next_heuristic(page)
        if clicked:
            changed = await wait_for_page_change(page, sig, timeout_ms=18000)
            if not changed:
                # Likely validation errors; let user handle, then continue
                if DEBUG:
                    print("[DEBUG] Next clicked but page did not change (validation?). Re-scanning same page.")
                await page.wait_for_timeout(600)
            else:
                # New page loaded
                await page.wait_for_load_state("domcontentloaded")
                await page.wait_for_timeout(250)
        else:
            # Could not find Next automatically; ask user
            print("[warn] Could not auto-find a Next button on this page.")
            input("Please click Next manually in the browser, then press ENTER to continue...")
            changed = await wait_for_page_change(page, sig, timeout_ms=18000)
            if not changed and DEBUG:
                print("[DEBUG] Manual Next did not trigger page change (still same page).")

    await ctx.close()
    await browser.close()

# ---------------- CLI ----------------
async def main():
    ap = argparse.ArgumentParser(description="Qualtrics auto-filler with human typing + robust page-change detection.")
    ap.add_argument("--csv", default="data/data_input.csv", help="Path to CSV (default: data/data_input.csv)")
    ap.add_argument("--mapping", default="mapping.json", help="Path to mapping JSON (default: mapping.json)")
    ap.add_argument("--start-url", default=None, help="Form start URL. If omitted, uses mapping['start_url'].")
    ap.add_argument("--headless", action="store_true", help="Run headless (default is headful)")
    ap.add_argument("--auto-next", action="store_true", help="After QID74 pause, click Next automatically when you press ENTER.")
    ap.add_argument("--type-delay", type=int, default=80, help="Per-character delay in ms for typing (default: 80)")
    ap.add_argument("--debug", action="store_true", help="Verbose debug logging")
    args = ap.parse_args()

    global DEBUG
    DEBUG = args.debug

    mapping = json.loads(Path(args.mapping).read_text(encoding="utf-8"))
    start_url = args.start_url or mapping.get("start_url")
    if not start_url or "YOUR-START-URL" in start_url:
        sys.exit("Please provide --start-url or set 'start_url' in mapping.json")

    df = pd.read_csv(args.csv, dtype=str).fillna("")

    async with async_playwright() as pw:
        for _, row in df.iterrows():
            await run_row(
                pw, start_url, mapping, row.to_dict(),
                headless=args.headless, auto_next_after_qid74=args.auto_next,
                per_char_delay_ms=args.type_delay
            )

if __name__ == "__main__":
    asyncio.run(main())
